---
layout: article
title: "Android IO 性能优化"
tags: PerformanceOptimization
aside:
  toc: true
---

## 为什么需要 IO 优化?
在进行 IO 操作的过程中, CPU 和内存都是高速的存储设备, 因此磁盘的读写会成为整个 IO 的瓶颈所在, **因此处理好磁盘的读写, 能够提升应用整体的流畅度**

<!--more-->

## 如何进行 IO 优化
IO 优化及对磁盘 IO 的优化, 有以下几个角度
- 从手机厂商的角度
  - 使用更大的内存 
    - 当内存不足时, Linux 会回收 PageCache 页缓存, 这就导致文件读写操作直接落盘, 直接 IO 带来底下的性能 
  - 使用更好的闪存
    - 闪存重复写入, 需要先进行擦除操作, 低端机磁盘碎片多, 剩余空间少, 一个内存页的写入会引起整个磁盘块的迁移, 造成耗时操作
  - 优化磁盘的文件系统
    - Linux 目前主流的是 ext4 文夹系统, 华为在 EMUI5.0 之后使用了 F2FS 取代了 ext4, 在系统小文件的随机读写方面比 ext4 更快
- 从开发者角度
  - 选择合适的文件读写操作
    - read/write
    - mmap
  - IO 方式的选择
    - 多线程阻塞 IO
    - 异步IO (IO)

### 一) 合适的系统调用
#### 1. 缓存 IO
![缓存 IO](https://i.loli.net/2019/06/21/5d0ca54e7b97719696.png)

对于读操作
- 内核首先尝试从页缓存中获取数据, 命中后直接拷贝到用户空间
- 未命中则从磁盘拷贝到页缓存, 再从页缓存拷贝到用户空间

对于写操作
- 内核从用户缓存区拷贝到页缓存
- 交由页缓存控制什么时候将数据 flush 到磁盘

```
// flush 每隔 5 秒执行一次
vm.dirty_writeback_centisecs = 500  
// 内存中驻留 30 秒以上的脏数据将由 flush 在下一次执行时写入磁盘
vm.dirty_expire_centisecs = 3000 
// 指示若脏页占总物理内存 10％以上，则触发 flush 把脏数据写回磁盘
vm.dirty_background_ratio = 10
// 系统所能拥有的最大脏页缓存的总大小
vm.dirty_ratio = 20
```

##### 设计目的
PageCache 页缓存, 可以避免每次都直接落盘带来的性能损耗
- 即使在内存上拷贝 100 次, 也比真正读一次磁盘速度要快

##### 适用场景
- 允许极低概率数据丢失的可能
  - 突然断电会导致数据丢失
- 对读写速度有较高的要求

#### 2. 直接 IO
![直接 IO](https://i.loli.net/2019/06/21/5d0ca5619ab3241629.png)

读操作
- 内核直接从磁盘拷贝到用户的缓冲区

写操作
- 内核从用户空间内存直接拷贝到磁盘

每次 IO 操作都直接落盘, 减少了一次数据拷贝

##### 目的
通过这种方式能够简单粗暴的保证数据能够及时落盘

##### 适用场景
- 对文件读写的速度要求不高
- 严格的保证数据不会丢失

#### 3. mmap 
mmap 系统调用是 Linux 提供的内存映射, 它有两种映射方式分别是匿名映射和文件映射
```
void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);
```
对于匿名映射
- 根据 length 找寻一块空间的虚拟内存, 这块虚拟内存, 用户空间和内核空间都可以操作, 无需在两者之间进行数据拷贝

对于文件映射
- 除了找寻虚拟内存之外, 还会让这块 vm_area 的结构体关联上文件系统的 ops, 即操作这块内存就等同于直接操作文件了

##### 优势
- 省去了在用户空间与内核空间之间拷贝的耗时操作
- 拥有 缓存 IO 的所有特性

![耗时对比](https://i.loli.net/2019/06/21/5d0ca57b29a0112304.png)   

##### 适用场景
- 适合于对同一块区域频繁读写的情况
- 跨进程通信
  - Binder 驱动 

### 二) IO 方式的选取
IO 的选取主要有两种, 分别为 多线程阻塞I/O 和异步 I/O

#### 1. 多线程阻塞 I/O
多线程阻塞 IO 为我们最常用的 IO 方式, 即将 IO 操作放在子线程中执行, 当进行 IO 时, 可能会阻塞子线程等待

Nexus 6P 读取 30 个大小为 40MB 的文件, 线程配置多少比较合理呢?
 
 ![image](https://i.loli.net/2019/06/21/5d0ca58f1445876125.png)
 
 可以看到, 30 个线程带来的收益并不会比 10 个线程来的好, 文件读写受到 I/O 性能瓶颈的影响, 在达到一定速度后, 整体性能就会受到明显影响, 过多的线程反而会增大上下文的开销
 

#### 2. 异步 I/O
异步 I/O 即将 I/O 以事件的方式通知, 来减少线程切换带来的开销, 不过它使程序变的更加复杂, 其最大的作用不是减少读取文件的耗时, 而是提升 CPU 整体的利用率

[Okio](https://github.com/square/okio) 支持同步和异步的 I/O, 做了很多的优化

## 总结
- 对于频繁读写的大文件, 使用 mmap 或 NIO 的方式
  - Java 对于 NIO 的封装对应着 MappedByteBuffer 
- Buffer 复用技术
  - Okio 中 ByteString 和 Buffer 通过重用等技巧, 很大程度上减少 CPU 和内存的消耗
  - Buffer 缓冲区的获取与磁盘块大小一致比较合适, 4kb 能够获得最佳性能
- 优化数据结构与算法优化
  - 降低 IO 操作的频率